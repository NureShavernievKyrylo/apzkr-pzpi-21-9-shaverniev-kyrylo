Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система контролю догляду за домашніми тваринами

     Студент гр. ПЗПІ-21-9
__ ________________Шавернєв К.О.
(підпис)
     Керівник роботи
____________ст.викл. Сокорчук І.П.
(підпис)
     
Роботу захищено «__»_____2024р.
3 оцінкою_____________________
     Комісія:
____________доц. Лещинський В.О.
(підпис)
     
______________доц. Лещинська І.О.
(підпис)
     
____________ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки  
  
Факультет комп’ютерних наук 	 	 Кафедра програмної інженерії          
Спеціальність 121 – Інженерія програмного забезпечення     	  	  	         
Курс     	3   	   Семестр    	 	6  	  	 	  	          
Навчальна дисципліна Архітектура програмного забезпечення                     

ЗАВДАННЯ  
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ   

   	  	  	           Шавернєву Кирилу Олексійовичу 	  	          	         
1. Тема проєкту: «Програмна система контролю догляду за домашніми тваринами»                             	  	                                          	        
2. Термін узгодження завдання з курсової роботи: «28» березня       2024 р.
3. Термін здачі студентом закінченої роботи: «10» серпня                  2024 р.
4. Вихідні дані до проєкту: Програмна система для автоматизації контролю догляду за домашніми тваринами. Передбачити в програмній системі відстеження та редагування графіку годувань, прогулянок, показників здоров’я тварини.                                                               	
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки	  	  	  	  	  	  	  	                                      
6. Перелік графічного матеріалу (з точним зображенням обов’язкових креслень): UML-діаграма розгортання, UML-діаграма прецедентів, UML-діаграма діяльності, ER-діаграма	  	  	                    	
КАЛЕНДАРНИЙ ПЛАН


№ 
Назви етапів курсової роботи 
Термін виконання етапів роботи
Примітка
1 
Функціональна специфікація
програмного проєкту
26.03.2023
 виконано
2 
Проектування програмного
проєкту
02.04.2024
 виконано
3 
Кодування програмного проєкту
25.04.2024
 виконано
4 
Оформлення пояснювальної
записки
28.05.2024
 виконано
5 
 Захист курсової роботи
08.06.2024
 виконано
Дата видачі теми проєкту «18» березня 2024 р.  
Керівник	
_________ ст. викл. Сокорчук І.П.
(підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІ-21-9
_________ Шавернєв К.О.
(підпис)


РЕФЕРАТ


     Пояснювальна записка до курсової роботи: 91 с., 31 рис., 3 табл., 3 додатки, 5 джерел.
     ВИГУЛ ТВАРИН, ВЛАСНИК ТВАРИНИ, ГОДІВЛЯ, ДОГЛЯД, ДРЕСИРУВАННЯ, ДОМАШНІ УЛЮБЛЕНЦІ, РОЗКЛАД, ТВАРИНИ.
     
     Об’єктом дослідження курсової роботи є галузь догляду за домашніми тваринами, зокрема контроль за їх годуванням, вигулом та здоров’ям.
     Метою курсової роботи є розробка системи, яка буде зберігати інформацію про власників тварин, дані про кожну тварину, такі як вид, стать, вік, а також записи про годування, прогулянки та здоров'я кожної з тваринок. 
     Методи розробки базуються на технології Django та базі даних PostgreSQL. Веб-застосунок базується на технології React. Смарт-пристрій розроблено на базі плати ESP32 з використанням датчиків для збору даних про температуру тварини за допомогою сервісу Wokwi та мови програмування С++.
     У результаті роботи здійснено програмну реалізацію системи контролю догляду за домашніми тваринами. Програмна система складається з сервера, веб-застосунку та смарт-пристрою.


ЗМІСТ


ВСТУП	6
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	7
1.1	Бізнес-вимоги	7
1.1.1	Бізнес можливості	7
1.1.2 Бізнес-цілі та критерії успіху	8
1.1.3 Потреби клієнтів або ринку	8
1.1.4 Бізнес-ризики	9
1.2	Концепція рішення	10
1.2.1	Окреслення концепції	10
1.2.2	Головна функціональність	11
1.2.3	Припущення та залежності	11
1.3	Рамки та обмеження проєкту	12
1.3.1	Рамки первинного випуску	12
1.3.2 Рамки наступних випусків	13
1.3.3 Обмеження та винятки	14
1.4 Бізнес-контекст	15
1.4.1 Профілі зацікавлених сторін	15
1.4.2 Пріорітети проекту	16
1.4.3 Робоче середовище	17
2	ПОСТАНОВКА ЗАДАЧІ	19
3 ПРОЄКТУВАННЯ ТА АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	20
3.1 Проєктування серверної частини	20
3.2 Проектування програмної частини смарт-пристрою	29
3.3 Проєктування клієнтської частини програмної системи	35
4 ОПИС ПРОГРАМНОЇ СИСТЕМИ	40
4.1 Запуск застосунку	40
4.2 Демонстрація роботи веб-додатку	41
ВИСНОВКИ	50
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	51
ДОДАТОК А	52
ДОДАТОК Б	79
ДОДАТОК В	82

ВСТУП
     
     
     Предметна область – контроль і догляд за домашніми тваринами – охоплює широкий спектр аспектів, пов’язаних з організацією, моніторингом та поліпленням умов утримання тварин.
     Зростаюча популярність домашніх тварин і підвищення уваги до якості умов їх життя спричинили великий попит на діяльність, послуги та товари, пов'язані з доглядом за тваринами. Це призвело до того, що утримання домашнього улюбленця перетворилося на складне та комплексне завдання, яке вимагає значних знань, часу та залучення від власників.
     Збільшення кількості тварин і їхніх різноманітних потреб ще сильніше ускладнює процес догляду. Відстеження графіків годування, прогулянок, здоров'я та інших аспектів вимагає систематизації та автоматизації.
     Організація догляду за тваринами вимагає уважного планування та координації. Важливо забезпечити своєчасне виконання процедур, таких як годування, прогулянки, медичні огляди, і уникнути випадків, коли власник тварини забуває про важливі аспекти утримання тварини.
     Ці проблеми демонструють необхідність у комплексному рішенні – розробці програмної системи, яка здатна забезпечити користувачів надійним та зручним інструментом контролю догляду за життям домашніх тварин.


1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
     1.1 Бізнес-вимоги
     1.1.1 Бізнес можливості


     Проект "LeashBuddy" орієнтується на ринок додатків для ведення обліку та догляду за домашніми тваринами. В цьому сегменті ринку зафіксована зростаюча популярність, оскільки власники тварин все більше оцінюють прості та ефективні інструменти для ведення щоденного журналу та координації догляду за своїми улюбленцями.
     Продукт "LeashBuddy" відмінюється від конкурентів завдяки таким особливостям: ми надаємо інтегровані функції для ведення графіків годування та прогулянок, нагадувань та обміну порадами в одному простому інтерфейсі. Ми визначаємося як універсальний інструмент для всіх видів тварин.
     Конкурентні компанії включають PetPal та PawTracker. PetPal пропонує аналогічний функціонал, але обмежений видами тварин та не має деяких зручних функцій, які пропонує "LeashBuddy". PawTracker фокусується на відстеженні місцезнаходження тварин та не надає власнику повноцінний функціонал, необхідний для зручного контролю за твариною.
     Орієнтована модель монетизації "LeashBuddy" передбачає отримання прибутку через продаж користувачам платних підписок, які надають додаткові функції та сервіси для власників тварин. Ми сподіваємося привернути власників тварин, які цінують простоту та ефективність ведення обліку графіку та здоров'я своїх улюбленців через наш додаток.
     
     
     
     
     
     1.1.2 Бізнес-цілі та критерії успіху


BO-1: Впровадження системи на глобальному ринку.
BO-2: Зниження витрат на догляд та годування тварин.
BO-3: Покращення здоров’я та тривалості життя домашніх тварин. 
SC-1: Високі показники реєстрації нових користувачів: реєстрація щонайменше 100 000 користувачів протягом перших шести місяців роботи застосунку.
SC-2: Задоволеність користувачів додатку: понад 80% позитивних відгуків від постійних користувачів застосунку.
SC-3: Позитивні результати покращення процесу догляду за тваринами: зниження витрат на 5% та збільшення тривалості життя тварин на 10%.


     1.1.3 Потреби клієнтів або ринку


Види користувачів програмної системи: 
1. Власник тварини (користувач)
2. Адміністратор системи (адмін)
3. Працівник, що здійснює догляд за тваринами (працівник)
     
     Потреби власників тварини:
     – Зручний доступ до управління розкладом годування, вправ та інших аспектів догляду за улюбленцями через веб-інтерфейс;
     – Можливість призначати та редагувати дієти і вправи для своїх тварин, а також відстежувати виконання цих завдань;
     – Отримання сповіщень про зміни в стані тварини, нові рекомендації з догляду та інші важливі повідомлення для забезпечення найкращих умов догляду;

     Потреби адміністратора системи:
     – Управління всіма сутностями системи, такими як користувачі, тварини, розклади та вправи, для забезпечення цілісності та безперебійної роботи системи.
     – Можливість робити резервну копію бази даних. 

Потеби працівника:
     – Легкий доступ до інформації про призначені тваринам дієти та вправи, що дозволяє ефективно виконувати свою роботу.
     – Можливість редагування та перегляду розкладів для забезпечення індивідуального підходу до кожної тварини. 
     – Управління датчиками для моніторингу фізичного стану тварин та збирання даних про їхню активність.


     1.1.4 Бізнес-ризики
	
	
	Ризики:
     Впровадження проекту "LeashBuddy" може супроводжуватися кількома ризиками, серед яких основними є питання конфіденційності даних і можливі технічні збої, що можуть виникнути в будь-якій програмній системі. Особливо слід звернути увагу на потенційні загрози, що стосуються безпеки даних власників і їхніх домашніх тварин, зокрема під час використання пристроїв для моніторингу стану тварин. Неправильна обробка або інтерпретація таких даних може мати серйозні наслідки для здоров'я тварин. Отже, під час розробки системи необхідно ретельно враховувати всі фактори, які можуть вплинути на безпеку та зручність користувачів.
     Також варто враховувати ризики, пов'язані з конкурентною ситуацією на ринку. Конкуренти можуть запропонувати альтернативні рішення, які будуть більш привабливими для користувачів. Для збереження конкурентних позицій необхідно постійно проводити аналіз ринку, вдосконалювати функціональність системи та адаптуватися до змін потреб власників домашніх тварин.

Можливі дії:
     Для уникнення потенційної проблеми з технічними збоями варто впровадити здійснення регулярних тестів програмної системи, а також аудиту безпеки даних для виявлення та усунення можливих проблем ще на етапі розробки.
     Для зниження ризику втрати конкурентних позицій на ринку варто впровадити систему моніторингу діяльності конкурентів, регулярно оновлювати та розширювати функціонал системи, а також активно збирати й аналізувати відгуки користувачів для швидкого реагування на їхні потреби та вподобання.
     

     1.2 Концепція рішення 
     1.2.1 Окреслення концепції


     Система  призначена для забезпечення зручного контролю за тваринами. Основна мета полягає в наданні інструментів, які допоможуть власникам оптимізувати процеси догляду, забезпечити зручність використання та підвищити ефективність управління різними аспектами турботи про тварин.
     Система має забезпечувати зручний доступ до різноманітної інформації про тварин, а саме їх раціон, розклад прогулянок, тренувань, показаники температури.
     Важливо спроектувати систему таким чином, щоб вона забезпечувала високий рівень безпеки для захисту конфіденційної інформації клієнтів.
     Система повинна стати надійним інструментом для власників тварин та ветеринарів, що допоможе їм полегшити процес догляду за домашніми улюбленцями.
     
     
     1.2.2 Головна функціональність
     

MF-1. Реєстрація та профіль користувача;
MF-2. Графіки годування, прогулянок, тренувань;
MF-3. Нагадування та сповіщення;
MF-4. Відстеження здоров'я;
MF-5. Звіти та статистика;
MF-6. Автоматичне регулювання графіка годування;
MF-7. Моніторинг температури тварини;


     1.2.3 Припущення та залежності


     ПР-1: Власники тварин зможуть легко освоїти та використовувати інтерфейс LeashBuddy.
     З-1: Власники тварин повинні мати доступ до персонального комп’ютеру використання додатку.
     ПР-2: Користувачі системи будуть вводити коректну інформацію про годування, прогулянки та стан здоров'я тварин.
     З-2: Власники тварин повинні мати доступ до достатньої кількості інформації про своїх улюбленців.
     ПР-3: Система може зберігати та обробляти інформацію в базі даних без перешкод.
     З-3: Наявність стабільного та надійного інтернет-з'єднання для забезпечення роботи системи.
     ПР-4: Можливість вимірювати температуру тварини через IOT застосунок.
     З-4: Наявність і доступність на ринку надійних пристроїв для вимірювання температури тварин, а також їх сумісність із системою.


     1.3 Рамки та обмеження проєкту
     1.3.1 Рамки первинного випуску


     Програмна система включає в себе три частини: Back-end, IoT, Front-end.
     
     Серверна частина (Back-end):
     – реєстрація та авторизація користувачів;
     – керування тваринами: додавання, редагування, видалення та відслідковування інформації про кожну тварину, включаючи ідентифікаційні дані, вид, стать, вік;
     – графіки годування та прогулянок: можливість додавати прості записи про годування та прогулянки, календарний вигляд для швидкого перегляду та внесення змін;
     – нагадування та сповіщення: налаштування простих нагадувань для годування, тренувань та прогулянок;
     – створення копії бази даних;

     IoT частина:
     – збір та відправлення на сервер даних про температуру тварини;
     
     Клієнтська частина (Front-end):
     – реєстрація та вхід користувачів до системи;
     – функціонал адміністратора, завдяки якому можна керувати усіма сутностями у системі;
     – інтуїтивно зрозумілий інтерфейс для будь-яких користувачів;
     – відображення даних у зручному форматі: списки, графіки, таблиці;


     1.3.2 Рамки наступних випусків


     В майбутньому проект буде масштабуватися та вдосконалюватися завдяки впровадженню наступного функціоналу:
     
     Серверна частина (Back-end):
     – представлення адміністраторам звітів та графіків для аналітики даних;
     – система рекомендацій: додавання системи, яка надаватиме власникам рекомендації щодо оптимальних умов для конкретних тварин та порад щодо їх догляду;

     Клієнтська частина (Front-end):
     – інтерактивні звіти та статистика: надання користувачам можливості перегляду докладних звітів і аналітики стосовно умов та активності тварин;
     – вдосконалення функціоналу робітників (ветеринар/дресувальник): унікальний функціонал для кожного з видів робітників, для поліпшення зручності взаємодії з тваринами та їх власниками;

     IOT-застосунки:
     – відстеження місцезнаходження тварини: окремий трекер, завдяки якому можливо спостерігати за пересуванням тварини на мапі в реальному часі;
     – розширення сенсорів: додавання нових сенсорів для вимірювання додаткових параметрів тварини.


     1.3.3 Обмеження та винятки


     Обмеження:
     – Необхідність у стабільному Інтернет-з’єднанні: Для коректної роботи системи необхідний постійний доступ до Інтернету. Відсутність Інтернету у користувача значно обмежує функціонал додатку;
     – Для забезпечення безпеки даних, система використовує шифрування та інші захисні механізми, що можуть вплинути на швидкість обробки інформації;



     1.4 Бізнес-контекст 
     1.4.1 Профілі зацікавлених сторін


     Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона
Головна цінність
Ставлення
Головні інтереси
Обмеження
Власник домашньої тварини.
Зручність догляду, здоров'я тварини, спокій.
Позитивне, очікує полегшення рутинних завдань.
Простий інтерфейс, надійність системи, можливість віддаленого моніторингу.
необхідність постійного підключення до інтернету
Ветеринар/дресирувальник
Покращення здоров'я або корекція поведінки тварин, співпраця з власниками
Нейтральне, бачить потенційні переваги
Інтеграція з ветеринарними клініками, доступ до медичної історії тварини
Час на освоєння нової системи
Розробник проєкту
Створення якісного продукту, розвиток професійних навичок
Позитивне, бажання створити корисний продукт
Створення масштабованої та стабільної системи, використання сучасних технологій
Терміни розробки, бюджетні обмеження
Виробник пристроїв IoT	
Розширення ринку збуту, партнерство з розробниками програмного забезпечення
Позитивне, бажання інтегрувати свої пристрої в систему
Сумісність з різними пристроями.
Технічні обмеження  обмеження 
пристроїв

     
     
     1.4.2 Пріорітети проекту
     

     Таблиця 1.2 – Пріоритети проєкту
Показник
Виконання (етапи)
Обмеження (граничні значення)
Ступінь свободи (допустимий діапазон)
План робіт
Версія 1.0 має бути готова до 08.06.24.
Розробка проєкту має бути завершена у зазначені сроки
Необхідність вкластися саме у зазначені терміни
     
Функціональність

     
90% функціоналу має працювати на релізі 1.0
Якість

     
У випуску 1.0 повинні пройти 100% тестувань
Персонал

Максимальний розмір команди – один розробник 
     
Ціна
     
Відсутній бюджет проекту

     
     
     1.4.3 Робоче середовище
     
     
     Для розробки серверної частини системи буде використано мову програмування Python разом із фреймворком Django, який забезпечує надійний і масштабований підхід до розробки серверних додатків. У якості середовища розробки обрано Visual Studio Code, яке забезпечує зручний та ефективний процес програмування.
     У якості система управління базами даних (СУБД) буде використано PostgreSQL. Ця база даних відрізняється своєю високою стійкістю, ефективністю при обробці великих обсягів даних та підтримкою складних SQL-запитів. PostgreSQL є відмінним вибором завдяки своїй гнучкості та можливості масштабування, що робить її підходящою для управління даними в масштабних проектах, таких як система контролю за домашніми тваринами.
     Для розробки клієнтської частини буде застосовано бібліотеку React. React є популярним інструментом для створення динамічних та інтерактивних веб-інтерфейсів, забезпечуючи швидку рендеризацію і зручність у розробці користувацьких інтерфейсів. Для оформлення зовнішнього вигляду будуть застосовані HTML та CSS, що дозволить створити сучасний та зручний інтерфейс для кінцевого користувача.
     	Розробка логіки IOT-застосунку буде виконана завдяки сервісу Wokwi та мові програмування С++.

2 ПОСТАНОВКА ЗАДАЧІ


     Ретельний аналіз предметної області допоміг визначити особливості створення програмної системи для контролю догляду за домашніми тваринами.
     База даних має містити наступну інформацію: дані про користувачів, тварин, графіки годування, прогулянок, тренувань, сповіщення, результати роботи IOT-застосунку (вимір температури тварини).
     У системі має бути реалізований наступний функціонал для користувача:
     – Реєстрація, авторизація, вхід у систему;
     – Створення, перегляд, редагування та видалення раціонів для тварин;
     – Створення, перегляд, редагування та видалення вправ для тварини;
     – Створення, перегляд, редагування та видалення прогулянок;
     – Отримання нагадувань про годування, прогулянки та вправи з твариною;
     – Перегляд результатів роботи IOT-застосунку;
     – Створення, перегляд, редагування та видалення записів про тварин;
     У системі має бути реалізований наступний додатковий функціонал для адміністратора:
     – Перегляд, редагування та видалення усіх сутностей системи;
     – Створення резервної копії бази даних;
     

3 ПРОЄКТУВАННЯ ТА АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
     3.1 Проєктування серверної частини


     Спершу потрібно змоделювати усі сутності властиві системі. Для цього необхідно розробити ER-модель даних, яка буде відображати всі сутності а також зв’язки між ними (рис. 3.1.1).
     

Рис. 3.1.1 – ER-модель даних у системі


     Система містить у собі наступні сутності та поля:
a) Користувач:
1) Користувач_id
2) Пошта
3) Телефон
4) Адреса
5) Ім’я
6) Прізвище
7) Роль
б) Питомець:
		1) Питомець_id
		2) Користувач_id
		3) Ім’я
		4) Порода
		5) Вік
		6) Стать
		7) Вага
в) Дієта:
		1) Дієта_id
		2) Тип_годування
		3) Кількість
		4) Примітки
г) Питомець_дієта
		1) Питомець_дієта_id
		2) Дієта_id
		3) Дата
д) Вправи
		1) Вправа_id
		2) Тип_вправ
		3) Тривалість
е) Питомець_вправи
		1) Питомець_вправи_id
		2) Вправа_id
		3) Дата
є) Датчик
		1) Датчик_id
		2) Питомець_id
		3) Температура
		4) Час_дата

     На основі визначених раніше сутностей і полів, які забезпечують необхідну функціональність системи, тепер можемо перейти до розгляду сценаріїв її використання. Описаний функціонал розподілений між п'ятьма основними акторами: гість, користувач, працівник (ветеринар/дресирувальник), адміністратор та IOT-застосунок.
     Починаючи взаємодію з системою, користувач знаходиться в ролі гостя, що дозволяє лише бачити відображення головної сторінки, сторінки реєстрації та авторизації. Для доступу до більшого функціоналу користувачеві необхідно зареєструватися та увійти в систему.
     
     Після входу, користувач може діяти як простий користувач, робітник або адміністратор. 
     Простий користувач має можливість переглядати, додавати, редагувати список своїх тварин, призначати для них дієту, вправи, прогулянки.
     Працівником є довірена особа, що може взаємодіяти з певною твариною. Цим працівником може бути ветеринар, дресирувальник або просто наглядальник за твариною. Цьому типу користувачів доступна можливість взаємодіяти з певними тваринами, спостерігати за їх показниками, результатами роботу датчиків (вимір температури), керувати дієтою, вправами, прогулянками. 
     Адміністратор системи має доступ до усіх інших сутностей. Програма надає йому можливість створювати, редагувати, видаляти та переглядати сутності у системі. 
     Датчик вимірює поточну температуру тварини та передає цю інформацію на сервер.
     На основі цих сценаріїв було розроблено UML-діаграму прецедентів (рис. 3.1.2). У результаті концептуального моделювання предметної області були окреслені ключові сутності програмної системи, визначено їхні атрибути та розроблено дві відповідні діаграми.
     

Рис. 3.1.2 - UML-діаграма прецедентів
     
     Взаємодія між сервером, клієнтською частиною та IoT пристроями здійснюється через REST API, що забезпечує єдину структуру для інтеграції різних компонентів системи. Докладніша інформація про взаємодію між частинами системи відображена на UML-діаграмі розгортання (рис. 3.1.3).
     
     
     
     
     
     Рис. 3.1 – UML діаграма розгортання серверної частини застосунку
     
     Відображення основного функціоналу системи для користувачів продемонстровано на діаграмі активності (рис. 3.1.4). Вона покроково демонструє різноманітні дії користувача на шляху виконання певної задачі.
     
     
     Рис. 3.1.4 – діаграма активності
     
     Було проведено детальний аналіз функціональних вимог до системи, результатом якого став вибір технологічного стеку для розробки серверної частини. Для реалізації серверного компоненту було обрано фреймворк Django, доповнений Django REST Framework для побудови RESTful API. Вибір Django був обумовлений його потужним набором інструментів для швидкої розробки веб-додатків, а Django REST Framework значно спростив процес створення API.
     Архітектура системи базується на моделі "Model – Template - View" (MTV), яка є основою Django. Ця архітектура дозволяє чітко розділити логіку додатку на три основні компоненти: модель (для роботи з даними), вид (для обробки запитів) та шаблон (для відображення даних). Такий підхід забезпечує модульність, підтримуваність та масштабованість системи.
     Для зберігання даних була обрана реляційна база даних PostgreSQL. PostgreSQL була обрана завдяки своїй потужності, гнучкості та широким можливостям для роботи з даними. Інтеграція PostgreSQL з Django була реалізована за допомогою ORM (Object-Relational Mapper), що забезпечило зручну роботу з базою даних на рівні об'єктів.
     Структура проекту виглядає наступним чином:
1) Каталог Django Project:
а) Файл manage.py, завдяки якому здійснюється запуск сервера;
б) Файл settings.py, що містить у собі налаштування проекту;
в) Файл urls.py з конфігурацією проекту;
г) Файл api_urls.py для взаємодії з веб-додатком;
	2) Каталог Django App:
		а) Файл models.py з усіма моделями проекту;
		б) Файл views.py з логікою взаємодії з користувачем;
		в) Файл forms.py для визначення структури форм введення даних;
		г) Файл database_backup.py з функціоналом резервного копіювання бази даних проекту;
		д) Файл serializers.py містить визначення серіалізаторів для обробки даних моделей;

     У таблиці 3.1 представлено вичерпну специфікацію REST API, яка детально описує всі функції, що забезпечують взаємодію з веб-сервісами
     


     
     Таблиця 3.1 – Специфікація REST API
Посилання
Метод HTTP
Принцип роботи
/register
POST
Реєстрація користувача
/login
POST
Авторизація користувача
/logout
POST
Вихід з системи
/user
GET
Отримання даних профілю авторизованого користувача
/users/<int:pk>
GET
Отримання користувача за його ID
/users/<int:pk>
PUT
Оновлення користувача за його ID
/users/<int:pk>
DELETE
Видалення користувача за його ID
/diets
POST
Створення списку дієт
/diets
GET
Отримання списку дієт
/diets/<int:pk>
GET
Отримання дієти за її ID
/diets/<int:pk>
PUT
Оновлення дієти за її ID
/diets/<int:pk>
DELETE
Видалення дієти за її ID
/pets
POST
Створення списку домашніх тварин
/pets
GET
Отримання списку домашніх тварин
/pets/<int:pk>
GET
Отримання домашньої тварини за її ID
/pets/<int:pk>
PUT
Оновлення домашньої тварини за її ID
/pets/<int:pk>
DELETE
Видалення домашньої тварини за її ID
/exercises
POST
Створення списку вправ/прогулянок
/exercises
GET
Отримання списку вправ/ прогулянок
/exercises/<int:pk>
GET
Отримання вправи/прогулянки за її ID
/exercises/<int:pk>
PUT
Оновлення вправи/прогулянки за її ID
/exercises/<int:pk>
DELETE
Видалення вправи/прогулянки за її ID
/exercises/<int:pk>/details
GET
Отримання детальної інформації про вправу/прогулянку
/sensors
POST
Створення списку сенсорів
/sensors
GET
Отримання списку сенсорів
/sensors/<int:pk>
GET
Отримання сенсора за його ID
/sensors/<int:pk>/
PUT
Оновлення сенсора за його ID
/sensors/<int:pk>/
DELETE
Видалення сенсора за його ID
/pets/<int:pk>/care-data/
GET
Отримання даних про догляд за домашньою твариною
/pet-diets/
POST
Створення списку раціонів харчування
/pet-diets/
GET
Отримання списку раціонів харчування
/pet-diets/<int:pk>/
GET
Отримання раціону харчування за його ID
/pet-diets/<int:pk>/
PUT
Ооновлення раціону харчування за його ID
/pet-diets/<int:pk>/
DELETE
Видалення раціону харчування за його ID
/pets/<int:pk>/diets/
GET
Отримання списку раціонів харчування для певної тварини
/pet-exercises/
POST
Створення списку вправ/прогулянок для домашньої тварини
/pet-exercises/
GET
Отримання списку вправ/прогулянок для домашньої тварини
/pet-exercises/<int:pk>/
GET
Отримання вправи/прогулянки для домашньої тварини за її ID
/pet-exercises/<int:pk>/
PUT
Оновлення вправи/прогулянки для домашньої тварини за її ID
/pet-exercises/<int:pk>/
DELETE
Видалення вправи/прогулянки для домашньої тварини за її ID
/pets/<int:pk>/exercises/
GET
Отримання списку вправ/прогулянок для певної тварини
/pets/<int:pk>/average-diet/
GET
Отримання середнього раціону харчування для тварини
/pets/<int:pk>/average-exercise/
GET
Отримання середньої тривалості тренувань/прогулянок для тварини
/pets-list/
GET
Отримання списку всіх домашніх тварин
/pet-diets/by-diet/
GET
Отримання раціонів харчування за типом їжі
/pet-exercises/by-exercise/
GET
Отримання вправ за типом вправи
/backup/
POST
Створення резервної копії бази даних

     

     3.2 Проектування програмної частини смарт-пристрою
     
     
     Датчик (IOT-застосунок) взаємодіє з твариною, вимірюючи її температуру. Далі ця інформація передається на сервер, звідки користувачі можуть переглянути поточні результати роботи термометру. Принцип роботи IOT-застосунку продемонстровано на UML діаграмі прецедентів (див рис. 3.3)
     
     
     Рис. 3.2.1 – діаграма активності
     
     
     Для створення системи, яка б дозволяла здійснювати моніторинг стану здоров'я тварин, було обрано платформу Arduino. Цей вибір обумовлений її доступністю, простотою використання та широкими можливостями для розробки IoT-пристроїв. Для зв’язку з сервером використовується протокол HTTP, де задіяні бібліотеки WiFi та HTTPClient. Збір даних з сенсора температури забезпечується через бібліотеку HX711, яка дозволяє зчитувати інформацію з датчика. Після підключення до Wi-Fi мережі, програма починає передавати ці дані на сервер. Відправка здійснюється через HTTP POST-запит. Для структурування даних в запиті використовується формат application/x-www-form-urlencoded. Цей формат дозволяє передавати дані у вигляді пар "ключ-значення", що спрощує їх обробку на сервері. Для наочного представлення взаємодії компонентів системи була розроблена діаграма пакетів (див. рис. 3.2.2). Діаграма демонструє процес збору даних з датчика, формування HTTP-запиту та передачі його на сервер.
     
     

     Рис. 3.2.2 – UML діаграма пакетів для IoT частини системи
     
     Для демонстрації принципу взаємодії IOT-застосунку з користувачем системи було розроблено діаграму взаємодії, яка зображена на рис. 3.2.3
     

     Рис. 3.2.3 – Діаграма взаємодії для IoT-застосунку

	Для відображення принципу взаємодії IOT-пристрою з сервером було створено діаграму діяльності, яка зображена на рис. 3.2.4.


Рис. 3.2.4 - Діаграма діяльності IOT-застосунку



     Для визначення взаємодії IoT девайсу та системи було використано UML діаграму взаємодії (див. рис. 3.5).

     Рисунок 3.5 – Діаграма взаємодії
     
     
     
     

     3.3 Проєктування клієнтської частини програмної системи
     
     
     Для реалізації веб-частини проекту було обрано технологічний стек, що складається з React, JavaScript, useState, useEffect та Axios. Це рішення дозволило створити масштабовану та ефективну систему. Використання React Hooks спростило управління станом компонентів, а Axios забезпечив надійну взаємодію з сервером. Завдяки архітектурі SPA, більша частина логіки додатку виконується на стороні клієнта, що покращує продуктивність та зменшує навантаження на сервер.
     
     Для ілюстрації структури системи та способу взаємодії її складових частин було відтворено UML діаграму компонентів веб-клієнту системи (див. рис. 3.3.1).
     

Рис. 3.3.1 - Діаграма компонентів веб-системи




     Для того щоб чітко визначити основні функції та взаємодії користувача з системою, було створено UML діаграму станів (рис. 3.3.2), яка детально описує можливі стани системи та переходи між ними
      
Рисунок 3.3.2 – UML діаграма станів веб-клієнту системи

     Було виділено стани клієнтської частини:
     – Авторизація: Користувач вводить свої облікові дані для доступу до системи;
     – Реєстрація: Створення нового облікового запису;
     – Перегляд тварин: інтерфейс для відображення даних про тварин користувача, їх створення, перегляд, редагування та видалення;
     – Перегляд дієт: інтерфейс для відображення даних про доступні для тварин раціони харчування, їх створення, перегляд, редагування та видалення;
     – Перегляд вправ та прогулянок: інтерфейс для відображення даних про передбачені для тварин заняття або прогулянки, їх створення, перегляд, редагування та видалення;
     – Перегляд резульатів роботи OIT-застосунків: інтерфейс для відображення вимірюваної температури у тварин;

     Для детального аналізу функціональних можливостей системи було створено діаграму діяльності (див. рис. 3.3.3). Вона дозволяє зрозуміти, як користувач може виконувати різні завдання в системі та які етапи при цьому проходить.

Рисунок 3.3.3 - UML діаграма діяльності веб-клієнту системи



4 ОПИС ПРОГРАМНОЇ СИСТЕМИ
     4.1 Запуск застосунку
     
     
     Для запуску веб-застосунку, потрібно завантажити архів з репозиторію. Відкрити завантажені файли у середовищі розробки Visual Studio Code, або іншому.
     Для запуску серверу необхідно запустити файл manage.py, прописавши у консолі команду “python manage.py runserver”. Після цього відобразиться відповідне повідомлення про початок роботи серверу (рис. 4.4.1) .
     
     
     Рисунок 4.1.1 – Запуск серверної частини системи
     
     Наступним кроком відбувається запуск клієнтської частини використанням команди “npm start”. Це призведе до відкриття сторінки браузеру з веб-застосунком за адресою http://localhost:3000/ (див. рис. 4.1.2). 
     

     Рисунок 4.1.2 – Запуск клієнтської частини
     Для відображення коректної симуляції роботи IOT-застосунку, необхідно перейти на онлайн сервіс Wokwi та запустити симуляцію роботу датчиків у реальному часі (рис. 4.1.3).
     

     Рисунок 4.1.3 – Запуск симуляції роботи смарт-пристрою
     

     4.2 Демонстрація роботи веб-додатку
     
     
     При запуску веб-додатку перед користувачем з’являється вікно з привітанням та пропозицією скористатися функціоналом застосунку: перехід до розділу з тваринами, раціонами харчування, вправами/прогулянками та датчиками (рис. 4.2.1). При натисканні на одну з запропонованих опцій або на кнопку логіну користувач побачить перед собою вікно авторизації (рис. 4.2.2). Якщо у користувача немає аккаунту він може перейти до сторінки реєстрації та створити новий обліковий запис (рис. 4.2.3).
     

     Рисунок 4.2.1 – Головна сторінка веб-застосунку
     

     Рисунок 4.2.2 – Вікно авторизації
     
     Рисунок 4.2.3 – Вікно реєстрації
     

	Після реєстрації або авторизації користувач отримує доступ до функціоналу застосунку. Перейшовши на вікно зі своїми тваринами (рис. 4.2.4), користувач може переглянути список своїх тварин та внести до нього корективи.


     Рисунок 4.2.4 – Сторінка з тваринами власника
     
     Після вибору первної тварини (клавіша Details) користувач пеходить до вікна менеджементу раціону та занять з твариною (рис. 4.2.5). Тут власник може переглядати та редагувати данні тварини, додавати записи про годування (рис. 4.2.6), вправи та прогулянки (рис. 4.2.7) з твариною. Також на сторінці відображено результат роботи смарт-девайсу, якщо той активовано. Окрім додавання записів, користувач може переглянути графіки годування (рис. 4.2.8) та вправ/прогулянок (рис. 4.2.9) з твариною.
     

     Рис. 4.2.5 – Сторінка менеджменту обраної тварини
     

     Рис. 4.2.6 – Додавання запису про про годування тварини обраною опцією зі списку раціонів
     

     Рис. 4.2.7 – Додавання запису про про вправи/вигул тварини з обраною опцією зі списку
     
     

Рис. 4.2.8 – Відображення графіку годувань


Рис. 4.2.9 – Відображення графіку вправ/прогулянок

     Перейшовши до вкладинки Diets, користувачу відобразяться усі раціони, які він або робітник (наглядальник за твариною) додали раніше (рис. 4.2.10). Окрім перегляду на цій вкладинці можна створювати нові можливі раціони (рис. 4.2.11) та редагувати вже існуючі (рис. 4.2.12).
Рис. 4.2.10 – усі доступні раціони


Рис. 4.2.11 – створення нового запису з можливим прийманням їжі

 Рис. 4.2.12 –  перегляд певного прийому їжі з можливістю редагування

	Перейшовши до розділу з вправами, користувач може переглянути усі створені активності з твариною. Це може бути відвідування ветеринару, заняття з дресирувальником або звичайна прогулянка (рис. 4.2.13). Користувач може створити новий запис, додавши назву та час, який займає активність (рис. 4.2.14).


Рис. 4.2.13 –  усі доступні активності для тварин


Рис. 4.2.14 –  створення нової активності

	На вкладинці Sensors користувач може переглянути усі увімкнені пристрої, що вимірюють температуру тварин (рис. 4.2.15).
 Рис. 4.2.15 –  увімкнені сенсори

	Окрім продемонстрованого вище функціоналу адміністратор має можливість зробити резервну копію бази даних. Для цього потрібно обрати опцію Backup Database та увести пароль від бази даних (рис. 4.2.16).




Рис. 4.2.16 –  вікно створення резервної копії бази даних
     
     
     
     
     
     
     
     
     
     
     
     
     
     




ВИСНОВКИ
     
     
     Результатом виконання роботи стала програмна система контролю догляду за домашніми тваринами.
     Під час роботи було проаналізовано предметну область, спроектовано та реалізовано базу даних, серверну, клієнтську частину та IOT застосунок.
     Результатом роботи стала повноцінна система, яка задовольняє всі поставлені завдання. Був розроблений інтуїтивно зрозумілий інтерфейс користувача на основі React, забезпечене надійне зберігання даних у PostgreSQL та створена гнучка серверна частина на Python з використанням Django. Для спеціалізованого обладнання був розроблений код на C++ з використанням Arduino. 
     Розроблена система “LeashBuddy” надає комплексний інструментарій для контролю домашніх тварин. Вона надає користувачу увесь необхідний функціонал для менеджменту годування, вправ та прогулянок з твариною, забезпечує зручний доступ до необхідної інформації та має можливість створення резервної копії даних для безпеки.
     
     


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
     
     
     1. Документація PostgreSQL: https://www.postgresql.org/docs/ (дата звернення 15.04.2024)
     2. Документація React: https://legacy.reactjs.org/docs/getting-started.html (дата звернення 11.05.2024) 
     3. React Reference Overview: URL: https://react.dev/reference/react (дата звернення: 12.05.2024).
     4. Kamal R. Embedded Systems - Architecture, Programming and Design. Tata McGraw Hill, 2008. 
     5. Відеозапис з демонстрацією курсової роботи - https://youtu.be/gs7F4pAjxbM. 


ДОДАТОК А
     Програмний код серверної частини
     А.1 Код файлу forms.py:
     
     
       1 from django import forms
       2 from django.utils.translation import gettext_lazy as _
       3 from .models import *
       4 import re
       5 
       6 
       7 class UserRegistrationForm(forms.ModelForm):
       8     password = forms.CharField(label='Password', widget=forms.PasswordInput)
       9     confirm_password = forms.CharField(label='Confirm Password', widget=forms.PasswordInput)
       10 
       11     class Meta:
       12         model = User
       13         fields = ['email', 'first_name', 'second_name', 'password', 'confirm_password', 'role', 'phone', 'address']
       14 
       15     def clean_email(self):
       16         email = self.cleaned_data.get('email')
       17         if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
       18             raise forms.ValidationError("Please enter a valid email address.")
       19         return email
       20 
       21     def clean_password(self):
       22         password = self.cleaned_data.get('password')
       23         if len(password) < 8:
       24             raise forms.ValidationError("Password must be at least 8 characters long.")
       25         return password
       26 
       27     def clean_confirm_password(self):
       28         password = self.cleaned_data.get('password')
       29         confirm_password = self.cleaned_data.get('confirm_password')
       30 
       31         if password and confirm_password and password != confirm_password:
       32             raise forms.ValidationError("Passwords do not match")
       33 
       34         return confirm_password
       35 
       36     def save(self, commit=True):
       37         user = super(UserRegistrationForm, self).save(commit=False)
       38         user.set_password(self.cleaned_data['password'])
       39         if commit:
       40             user.save()
       41         return user
       42 
       43 
       44 class LoginUserForm(forms.Form):
       45     email = forms.EmailField()
       46     password = forms.CharField(widget=forms.PasswordInput)
       47
       
     А.2 Код файлу models.py
     
     
       1 from django.db import models
       2 from django.contrib.auth.models import AbstractBaseUser, BaseUserManager
       3 from django.utils import timezone
       4 
       5 # Custom manager for the User model
       6 class UserManager(BaseUserManager):
       7     # Method to create a regular user
       8     def create_user(self, email, password=None, **extra_fields):
       9         if not email:
       10             raise ValueError('The Email field must be set')
       11         email = self.normalize_email(email)
       12         user = self.model(email=email, **extra_fields)
       13         user.set_password(password)
       14         user.save(using=self._db)
       15         return user
       16 
       17     # Method to create a superuser
       18     def create_superuser(self, email, password=None, **extra_fields):
       19         extra_fields.setdefault('is_staff', True)
       20         extra_fields.setdefault('is_superuser', True)
       21 
       22         if extra_fields.get('is_staff') is not True:
       23             raise ValueError('Superuser must have is_staff=True.')
       24         if extra_fields.get('is_superuser') is not True:
       25             raise ValueError('Superuser must have is_superuser=True.')
       26 
       27         return self.create_user(email, password, **extra_fields)
       28 
       29 # Custom User model extending AbstractBaseUser
       30 class User(AbstractBaseUser):
       31     # Role choices for the User model
       32     ROLE_CHOICES = [
       33         ('user', 'User'),
       34         ('wor', 'Worker'),
       35         ('admin', 'Admin'),
       36     ]
       37 
       38     # User model fields
       39     email = models.EmailField(unique=True)
       40     password = models.CharField(max_length=128)
       41     phone = models.CharField(max_length=15, blank=True, null=True)
       42     address = models.TextField(blank=True, null=True)
       43     first_name = models.CharField(max_length=100, blank=True, null=True)
       44     second_name = models.CharField(max_length=100, blank=True, null=True)
       45     role = models.CharField(max_length=50, choices=ROLE_CHOICES, default='user')
       46 
       47     # Fields for user status
       48     is_active = models.BooleanField(default=True)
       49     is_staff = models.BooleanField(default=False)
       50 
       51     # Use the custom manager for user creation
       52     objects = UserManager()
       53 
       54     # Specify the field used for authentication
       55     USERNAME_FIELD = 'email'
       56 
       57     def __str__(self):
       58         return self.email
       59 
       60 # Model to represent a pet
       61 class Pet(models.Model):
       62     user = models.ForeignKey(User, on_delete=models.CASCADE)
       63     name = models.CharField(max_length=100)
       64     breed = models.CharField(max_length=100)
       65     age = models.IntegerField()
       66     gender = models.CharField(max_length=10)
       67     weight = models.FloatField()
       68 
       69     def __str__(self):
       70         return f"{self.name} ({self.breed})"
       71 
       72 # Model to represent a diet for a pet
       73 class Diet(models.Model):
       74     food_type = models.CharField(max_length=100)
       75     quantity = models.FloatField()
       76     notes = models.TextField(blank=True, null=True)
       77 
       78     def __str__(self):
       79         return f"{self.food_type} ({self.quantity}g)"
       80 
       81 # Model to represent an exercise activity for a pet
       82 class Exercise(models.Model):
       83     exercise_type = models.CharField(max_length=100)
       84     duration = models.DurationField()
       85 
       86     def __str__(self):
       87         return f"{self.exercise_type} ({self.duration})"
       88 
       89 # Model to represent a sensor associated with a pet
       90 class Sensor(models.Model):
       91     pet = models.ForeignKey(Pet, on_delete=models.CASCADE, blank=True, null=True)
       92     temperature = models.FloatField()
       93     timestamp = models.DateTimeField(auto_now_add=True)
       94 
       95     def __str__(self):
       96         return f"Sensor for {self.pet.name if self.pet else 'No Pet'} at {self.timestamp}"
       97 
       98 # Model to represent the relationship between a pet and its diet
       99 class PetDiet(models.Model):
       100     pet = models.ForeignKey(Pet, on_delete=models.CASCADE)
       101     diet = models.ForeignKey(Diet, on_delete=models.CASCADE)
       102     date = models.DateField()
       103 
       104     def __str__(self):
       105         return f"{self.pet.name} diet on {self.date}"
       106 
       107 # Model to represent the relationship between a pet and its exercise
       108 class PetExercise(models.Model):
       109     pet = models.ForeignKey(Pet, on_delete=models.CASCADE)
       110     exercise = models.ForeignKey(Exercise, on_delete=models.CASCADE)
       111     date = models.DateField()
       112 
       113     def __str__(self):
       114         return f"{self.pet.name} exercise on {self.date}"
       115 
       116 # Model to represent the overall care for a pet, including diet, exercise, and sensor data
       117 class Care(models.Model):
       118     pet = models.ForeignKey(Pet, on_delete=models.CASCADE)
       119     diet = models.ForeignKey(Diet, on_delete=models.CASCADE, blank=True, null=True)
       120     exercise = models.ForeignKey(Exercise, on_delete=models.CASCADE, blank=True, null=True)
       121     sensor = models.ForeignKey(Sensor, on_delete=models.CASCADE, blank=True, null=True)
       122     care_date = models.DateField(default=timezone.now)
       123 
       124     def __str__(self):
       125         return f"Care record for {self.pet.name} on {self.care_date}"
       126 
       127 # Model to represent notifications sent to users
       128 class Notification(models.Model):
       129     user = models.ForeignKey(User, on_delete=models.CASCADE)
       130     text = models.TextField()
       131     time = models.DateTimeField(auto_now_add=True)
       132 
       133     def __str__(self):
       134         return f"Notification for {self.user.email} at {self.time}"
       
       
     А.3 Код файлу serializers.py
     
     
       1 from rest_framework import serializers
       2 from .models import *
       3 from django.contrib.auth import get_user_model, authenticate
       4 import logging
       5 from rest_framework.views import APIView, View
       6 from rest_framework import status, permissions, viewsets, generics
       7 from rest_framework.response import Response
       8 
       9 # =======================
       10 # User-related Serializers
       11 # =======================
       12 
       13 # Serializer for User model to handle standard fields
       14 class UserSerializer(serializers.ModelSerializer):
       15     class Meta:
       16         model = User
       17         fields = ['id', 'email', 'first_name', 'second_name', 'phone', 'address', 'role']
       18 
       19 # Serializer for user registration, includes password handling
       20 class UserRegisterSerializer(serializers.ModelSerializer):
       21     class Meta:
       22         model = User
       23         fields = ['email', 'password', 'first_name', 'second_name', 'phone', 'address', 'role']
       24         extra_kwargs = {
       25             'password': {'write_only': True}
       26         }
       27 
       28     # Override create method to handle password hashing
       29     def create(self, validated_data):
       30         user = User.objects.create_user(
       31             email=validated_data['email'],
       32             password=validated_data['password'],
       33             first_name=validated_data.get('first_name', ''),
       34             second_name=validated_data.get('second_name', ''),
       35             phone=validated_data.get('phone', ''),
       36             address=validated_data.get('address', ''),
       37             role=validated_data.get('role', 'user'),
       38         )
       39         return user
       40 
       41 # Serializer for user login, validating email and password
       42 class UserLoginSerializer(serializers.Serializer):
       43     email = serializers.EmailField()
       44     password = serializers.CharField(write_only=True)
       45 
       46     def validate(self, data):
       47         email = data.get('email')
       48         password = data.get('password')
       49 
       50         if email and password:
       51             # Use the authenticate method, and ensure email is used as username
       52             user = authenticate(request=self.context.get('request'), username=email, password=password)
       53             if user is None:
       54                 raise serializers.ValidationError('Invalid email or password.')
       55         else:
       56             raise serializers.ValidationError('Must include "email" and "password".')
       57 
       58         data['user'] = user
       59         return data
       60 
       61 
       62 # ====================
       63 # Pet-related Serializers
       64 # ====================
       65 
       66 # Serializer for the Pet model with related user
       67 class PetSerializer(serializers.ModelSerializer):
       68     user = UserSerializer(read_only=True)
       69 
       70     class Meta:
       71         model = Pet
       72         fields = ['id', 'name', 'breed', 'age', 'gender', 'weight', 'user']
       73         
       74 
       75 # Serializer to display user details along with their pets
       76 class UserDetailSerializer(serializers.ModelSerializer):
       77     pets = PetSerializer(many=True, read_only=True, source='pet_set')  # Try using pet_set as the source
       78 
       79     class Meta:
       80         model = User
       81         fields = ['id', 'email', 'first_name', 'second_name', 'phone', 'address', 'role', 'pets']
       82 
       83 # Serializer to handle a list of pets with basic fields
       84 class PetListSerializer(serializers.ModelSerializer):
       85     class Meta:
       86         model = Pet
       87         fields = ['id', 'name', 'breed', 'age', 'gender', 'weight']
       88 
       89 # Serializer to handle detailed pet care information
       90 class PetDetailSerializer(serializers.ModelSerializer):
       91     care_date = serializers.DateField()
       92     feeding_quantity = serializers.FloatField(source='diet.quantity', required=False)
       93     exercise_duration = serializers.DurationField(source='exercise.duration', required=False)
       94 
       95     class Meta:
       96         model = Care
       97         fields = ['care_date', 'feeding_quantity', 'exercise_duration']
       98 
       99 # ====================
       100 # Diet-related Serializers
       101 # ====================
       102 
       103 # Serializer for the Diet model with related pet
       104 class DietSerializer(serializers.ModelSerializer):
       105     pet = PetSerializer(read_only=True)
       106 
       107     class Meta:
       108         model = Diet
       109         fields = ['id',  'food_type', 'quantity', 'notes', 'pet']
       110 
       111 # Serializer to represent the relationship between a pet and its diet
       112 class PetDietSerializer(serializers.ModelSerializer):
       113     quantity = serializers.SerializerMethodField()
       114     pet_name = serializers.CharField(source='pet.name', read_only=True)
       115     diet_food_type = serializers.CharField(source='diet.food_type', read_only=True)
       116 
       117     class Meta:
       118         model = PetDiet
       119         fields = ['id', 'pet', 'diet', 'date', 'quantity', 'pet_name', 'diet_food_type']
       120 
       121     def get_quantity(self, obj):
       122         return obj.diet.quantity
       123 
       124 # View to list pet diet records filtered by diet ID
       125 class PetDietListView(generics.ListAPIView):
       126     serializer_class = PetDietSerializer
       127     permission_classes = [permissions.IsAuthenticated]
       128 
       129     def get_queryset(self):
       130         diet_id = self.request.query_params.get('diet', None)
       131         if diet_id:
       132             return PetDiet.objects.filter(diet_id=diet_id).order_by('date')
       133         return PetDiet.objects.none()  # Return an empty queryset if diet_id is not provided
       134 
       135 # =======================
       136 # Exercise-related Serializers
       137 # =======================
       138 
       139 # Serializer for the Exercise model with related pet
       140 class ExerciseSerializer(serializers.ModelSerializer):
       141     pet = PetSerializer(read_only=True)
       142 
       143     class Meta:
       144         model = Exercise
       145         fields = ['id',  'exercise_type', 'duration', 'pet']
       146 
       147 # Serializer to represent the relationship between a pet and its exercise
       148 class PetExerciseSerializer(serializers.ModelSerializer):
       149     exercise_type = serializers.CharField(source='exercise.exercise_type')
       150     duration = serializers.DurationField(source='exercise.duration')
       151     
       152     class Meta:
       153         model = PetExercise
       154         fields = ['id', 'pet', 'exercise', 'exercise_type', 'duration', 'date']
       155 
       156 # Serializer to display detailed pet exercise information
       157 class PetExerciseDetailSerializer(serializers.ModelSerializer):
       158     pet_name = serializers.CharField(source='pet.name', read_only=True)
       159     exercise_type = serializers.CharField(source='exercise.exercise_type', read_only=True)
       160 
       161     class Meta:
       162         model = PetExercise
       163         fields = ['id', 'pet_name', 'exercise_type', 'date', 'duration']
       164 
       165 # =========================
       166 # Sensor-related Serializers
       167 # =========================
       168 
       169 # Serializer for the Sensor model with related pet
       170 class SensorSerializer(serializers.ModelSerializer):
       171     pet = PetSerializer(read_only=True)
       172 
       173     class Meta:
       174         model = Sensor
       175         fields = ['id', 'pet', 'temperature', 'timestamp']
       176 
       177 # =========================
       178 # Care-related Serializers
       179 # =========================
       180 
       181 # Serializer for the Care model with nested serializers for related models
       182 class CareSerializer(serializers.ModelSerializer):
       183     pet = serializers.PrimaryKeyRelatedField(queryset=Pet.objects.all())
       184     diet = serializers.PrimaryKeyRelatedField(queryset=Diet.objects.all(), allow_null=True, required=False)
       185     exercise = serializers.PrimaryKeyRelatedField(queryset=Exercise.objects.all(), allow_null=True, required=False)
       186     sensor = serializers.PrimaryKeyRelatedField(queryset=Sensor.objects.all(), allow_null=True, required=False)
       187     care_date = serializers.DateField(format="%Y-%m-%d")
       188 
       189     class Meta:
       190         model = Care
       191         fields = ['id', 'pet', 'diet', 'exercise', 'sensor', 'care_date']
       192 
       193 # Serializer to display detailed care information with nested details for diet, exercise, and sensor
       194 class CareDetailSerializer(serializers.ModelSerializer):
       195     pet = PetSerializer()  # Use nested serializer for full details
       196     diet = DietSerializer(allow_null=True, required=False)
       197     exercise = ExerciseSerializer(allow_null=True, required=False)
       198     sensor = SensorSerializer(allow_null=True, required=False)
       199     care_date = serializers.DateField(format="%Y-%m-%d")
       200 
       201     class Meta:
       202         model = Care
       203         fields = ['id', 'pet', 'diet', 'exercise', 'sensor', 'care_date']
       204 
       205 # API view to get pet care data, including diet quantity and exercise duration over time
       206 class PetCareDataView(APIView):
       207     def get(self, request, pk):
       208         care_records = Care.objects.filter(pet_id=pk).order_by('care_date')
       209         data = [
       210             {
       211                 'date': care.care_date,
       212                 'diet_quantity': care.diet.quantity if care.diet else None,
       213                 'exercise_duration': care.exercise.duration if care.exercise else None,
       214             }
       215             for care in care_records
       216         ]
       217         return Response(data)
       218 
       219 # =============================
       220 # Notification-related Serializers
       221 # =============================
       222 
       223 # Serializer for the Notification model with related user
       224 class NotificationSerializer(serializers.ModelSerializer):
       225     user = UserSerializer(read_only=True)
       226 
       227     class Meta:
       228         model = Notification
       229         fields = ['id', 'user', 'text', 'time']
       
       
     А.4 Код файлу views.py
       
       
       1 from datetime import datetime
       2 from django.shortcuts import render
       3 from django.http import HttpRequest, JsonResponse
       4 from rest_framework.views import APIView
       5 from rest_framework import status, permissions, viewsets, generics
       6 from rest_framework.response import Response
       7 from django.contrib.auth import authenticate, login, logout
       8 from rest_framework.exceptions import ValidationError
       9 from django.middleware.csrf import get_token
       10 from django.utils.decorators import method_decorator
       11 from django.views.decorators.csrf import csrf_exempt, ensure_csrf_cookie
       12 from rest_framework.decorators import action
       13 from rest_framework.permissions import IsAuthenticated
       14 from rest_framework.generics import RetrieveAPIView
       15 from django.db.models import Avg, DurationField, ExpressionWrapper, F
       16 from .serializers import *
       17 from .database_backup import backup_database
       18 
       19 
       20 # ====================
       21 # CSRF Token Handling
       22 # ====================
       23 
       24 # View to ensure the CSRF token is included in the cookies
       25 @ensure_csrf_cookie
       26 def get_csrf_token(request):
       27     return JsonResponse({'csrfToken': request.COOKIES['csrftoken']})
       28 
       29 
       30 # ====================
       31 # User Authentication Views
       32 # ====================
       33 
       34 # View to handle user registration
       35 class UserRegister(APIView):
       36     permission_classes = (permissions.AllowAny,)
       37 
       38     def post(self, request):
       39         serializer = UserRegisterSerializer(data=request.data)
       40         if serializer.is_valid(raise_exception=True):
       41             user = serializer.save()
       42             return Response(UserSerializer(user).data, status=status.HTTP_201_CREATED)
       43         return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
       44 
       45 # View to handle user login
       46 class UserLogin(APIView):
       47     permission_classes = (permissions.AllowAny,)
       48 
       49     def post(self, request):
       50         serializer = UserLoginSerializer(data=request.data)
       51         if serializer.is_valid(raise_exception=True):
       52             user = serializer.validated_data['user']
       53             login(request, user)
       54             user_data = UserSerializer(user).data
       55             print("User login successful. User data:", user_data)
       56             return Response({'user': user_data}, status=status.HTTP_200_OK)
       57         print("User login failed. Errors:", serializer.errors)
       58         return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
       59 
       60 # View to handle user logout
       61 class UserLogout(APIView):
       62     permission_classes = (permissions.AllowAny,)
       63 
       64     def post(self, request):
       65         logout(request)
       66         return Response(status=status.HTTP_200_OK)
       67 
       68 # View to retrieve the current user's details
       69 class UserView(APIView):
       70     permission_classes = (permissions.IsAuthenticated,)
       71 
       72     def get(self, request):
       73         serializer = UserSerializer(request.user)
       74         return Response({'user': serializer.data}, status=status.HTTP_200_OK)
       75     
       76 # View to list all users
       77 class UserListView(generics.ListAPIView):
       78     queryset = User.objects.all()
       79     serializer_class = UserSerializer
       80     permission_classes = [IsAuthenticated]
       81 
       82 # View to retrieve detailed information about a user and their pets
       83 class UserDetailView(RetrieveAPIView):
       84     queryset = User.objects.prefetch_related('pet_set').all()
       85     serializer_class = UserDetailSerializer
       86 
       87 # Custom permission to allow access only to the owner of the pet or an admin
       88 class IsOwnerOrAdmin(permissions.BasePermission):
       89     def has_object_permission(self, request, view, obj):
       90         # Allow access to admin users or the owner of the diet record
       91         return request.user.role == 'admin' or obj.pet.user == request.user
       92 
       93 
       94 # ====================
       95 # CRUD Operations for Diet
       96 # ====================
       97 
       98 # View to list and create Diet records
       99 class DietListCreate(generics.ListCreateAPIView):
       100     queryset = Diet.objects.all()
       101     serializer_class = DietSerializer
       102     permission_classes = [permissions.IsAuthenticated]
       103 
       104     def perform_create(self, serializer):
       105         try:
       106             serializer.save()
       107         except ValidationError as e:
       108             print(f'Validation Error: {e}')
       109             raise
       110 
       111 # View to retrieve, update, and delete Diet records
       112 class DietRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):
       113     queryset = Diet.objects.all()
       114     serializer_class = DietSerializer
       115     permission_classes = [permissions.IsAuthenticated]
       116 
       117     def perform_update(self, serializer):
       118         try:
       119             print("Received data for update:", self.request.data)
       120             serializer.save()
       121         except serializers.ValidationError as e:
       122             print(f'Validation Error: {e}')
       123             raise
       124 
       125     def perform_destroy(self, instance):
       126         instance.delete()
       127         
       128 
       129 # ====================
       130 # CRUD Operations for Pets
       131 # ====================
       132 
       133 # View to list and create Pet records
       134 class PetListCreate(generics.ListCreateAPIView):
       135     queryset = Pet.objects.all()
       136     serializer_class = PetSerializer
       137     permission_classes = [permissions.IsAuthenticated]
       138 
       139     def perform_create(self, serializer):
       140         serializer.save(user=self.request.user)
       141 
       142 # View to retrieve, update, and delete Pet records
       143 class PetRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):
       144     queryset = Pet.objects.all()
       145     serializer_class = PetSerializer
       146     permission_classes = [permissions.IsAuthenticated]
       147 
       148     def perform_update(self, serializer):
       149         serializer.save()
       150 
       151     def perform_destroy(self, instance):
       152         instance.delete()
       153 
       154 # View to retrieve detailed information about a pet and its related care data
       155 class PetDetailView(generics.RetrieveAPIView):
       156     queryset = Pet.objects.all()
       157     serializer_class = PetDetailSerializer
       158     permission_classes = [IsAuthenticated]
       159 
       160 # View to list pets based on user role
       161 class PetListView(generics.ListAPIView):
       162     serializer_class = PetListSerializer
       163     permission_classes = [permissions.IsAuthenticated]
       164 
       165     def get_queryset(self):
       166         user = self.request.user
       167         if user.role == 'user':
       168             return Pet.objects.filter(user=user)
       169         return Pet.objects.all()
       170 
       171 
       172 # ====================
       173 # CRUD Operations for Exercises
       174 # ====================
       175 
       176 # View to list and create Exercise records
       177 class ExerciseListCreate(generics.ListCreateAPIView):
       178     queryset = Exercise.objects.all()
       179     serializer_class = ExerciseSerializer
       180     permission_classes = [permissions.IsAuthenticated]
       181 
       182     def perform_create(self, serializer):
       183         serializer.save()
       184 
       185 # View to retrieve, update, and delete Exercise records
       186 class ExerciseRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):
       187     queryset = Exercise.objects.all()
       188     serializer_class = ExerciseSerializer
       189     permission_classes = [permissions.IsAuthenticated]
       190 
       191     def perform_update(self, serializer):
       192         serializer.save()
       193 
       194     def perform_destroy(self, instance):
       195         instance.delete()        
       196 
       197 # ====================
       198 # CRUD Operations for Sensors
       199 # ====================
       200 
       201 # View to list and create Sensor records
       202 class SensorListCreate(generics.ListCreateAPIView):
       203     queryset = Sensor.objects.all()
       204     serializer_class = SensorSerializer
       205     permission_classes = [permissions.IsAuthenticated]
       206 
       207     def perform_create(self, serializer):
       208         serializer.save()
       209 
       210 # View to retrieve, update, and delete Sensor records
       211 class SensorRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):
       212     queryset = Sensor.objects.all()
       213     serializer_class = SensorSerializer
       214     permission_classes = [permissions.IsAuthenticated]
       215 
       216     def perform_update(self, serializer):
       217         serializer.save()
       218 
       219     def perform_destroy(self, instance):
       220         instance.delete()
       221 
       222 # ==========================
       223 # Pet-Diet Relationship Views
       224 # ==========================
       225 
       226 # View to list and create PetDiet records
       227 class PetDietListCreate(generics.ListCreateAPIView):
       228     queryset = PetDiet.objects.all()
       229     serializer_class = PetDietSerializer
       230     #permission_classes = [permissions.IsAuthenticated]
       231 
       232 # View to retrieve, update, and delete PetDiet records
       233 class PetDietRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):
       234     queryset = PetDiet.objects.all()
       235     serializer_class = PetDietSerializer
       236     #permission_classes = [permissions.IsAuthenticated]
       237 
       238 # View to list PetDiet records filtered by Pet ID
       239 class PetDietListView(generics.ListAPIView):
       240     serializer_class = PetDietSerializer
       241 
       242     def get_queryset(self):
       243         pet_id = self.kwargs['pk']
       244         return PetDiet.objects.filter(pet_id=pet_id).order_by('date')
       245 
       246 # View to calculate the average diet quantity for a specific pet
       247 class PetDietAverageView(APIView):
       248     def get(self, request, pk):
       249         try:
       250             average_diet = PetDiet.objects.filter(pet_id=pk).aggregate(Avg('quantity'))
       251             if average_diet['quantity__avg'] is None:
       252                 return Response({'average_diet': 0}, status=status.HTTP_200_OK)  # Default to 0 if no records
       253             return Response({'average_diet': average_diet['quantity__avg']}, status=status.HTTP_200_OK)
       254         except Exception as e:
       255             return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
       256 
       257 # View to list PetDiet records filtered by Diet ID
       258 class PetDietByDietView(generics.ListAPIView):
       259     serializer_class = PetDietSerializer
       260     permission_classes = [permissions.IsAuthenticated]
       261 
       262     def get_queryset(self):
       263         diet_id = self.request.query_params.get('diet', None)
       264         if diet_id:
       265             return PetDiet.objects.filter(diet_id=diet_id).order_by('date')
       266         return PetDiet.objects.none()  # Return an empty queryset if diet_id is not provided
       267     
       268 
       269 # ============================
       270 # Pet-Exercise Relationship Views
       271 # ============================
       272 
       273 # View to list and create PetExercise records
       274 class PetExerciseListCreate(generics.ListCreateAPIView):
       275     queryset = PetExercise.objects.all()
       276     serializer_class = PetExerciseSerializer
       277     #permission_classes = [permissions.IsAuthenticated]
       278 
       279     def perform_create(self, serializer):
       280         serializer.save()
       281 
       282 # View to retrieve, update, and delete PetExercise records
       283 class PetExerciseRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):
       284     queryset = PetExercise.objects.all()
       285     serializer_class = PetExerciseSerializer
       286     #permission_classes = [permissions.IsAuthenticated]
       287 
       288     def perform_update(self, serializer):
       289         serializer.save()
       290 
       291     def perform_destroy(self, instance):
       292         instance.delete()
       293 
       294 # View to list PetExercise records filtered by Pet ID
       295 class PetExerciseListView(generics.ListAPIView):
       296     serializer_class = PetExerciseSerializer
       297 
       298     def get_queryset(self):
       299         pet_id = self.kwargs['pk']
       300         return PetExercise.objects.filter(pet_id=pet_id).order_by('date')
       301 
       302 # View to calculate the average exercise duration for a specific pet
       303 class PetExerciseAverageView(APIView):
       304     def get(self, request, pk):
       305         average_exercise = PetExercise.objects.filter(pet_id=pk).aggregate(
       306             avg_duration=Avg(ExpressionWrapper(F('exercise__duration'), output_field=DurationField()))
       307         )
       308         return Response({'average_exercise': average_exercise['avg_duration'].total_seconds() / 60 if average_exercise['avg_duration'] else None})
       309 
       310 # View to list PetExercise records filtered by Exercise ID
       311 class PetExerciseListByExerciseView(generics.ListAPIView):
       312     serializer_class = PetExerciseSerializer
       313     permission_classes = [IsAuthenticated]
       314 
       315     def get_queryset(self):
       316         exercise_id = self.request.query_params.get('exercise', None)
       317         if exercise_id:
       318             return PetExercise.objects.filter(exercise_id=exercise_id).order_by('date')
       319         return PetExercise.objects.none()  # Return an empty queryset if no exercise ID is provided
       320     
       321 # View to retrieve detailed information about a specific PetExercise record
       322 class PetExerciseDetailView(generics.RetrieveAPIView):
       323     queryset = PetExercise.objects.all()
       324     serializer_class = PetExerciseDetailSerializer
       325     permission_classes = [permissions.IsAuthenticated]
       326 
       327 
       328 # ====================
       329 # Database Backup View
       330 # ====================
       331 
       332 # View to handle the backup of the database
       333 class BackupDatabaseAPIView(APIView):
       334     permission_classes = [permissions.IsAuthenticated]
       335 
       336     def post(self, request):
       337         # Assuming you don't want role-based restrictions at the moment, so no check for admin role
       338         password = request.data.get('password')
       339         if not password:
       340             return Response({'message': 'Password is required.'}, status=status.HTTP_400_BAD_REQUEST)
       341         
       342         try:
       343             backup_file = backup_database(
       344                 host='localhost',
       345                 port='5432',
       346                 database='LeashBuddy',  # Replace with your actual database name
       347                 user='postgres',      # Replace with your actual database user
       348                 password=password
       349             )
       350             return Response({'message': 'Backup process initiated successfully.', 'backup_file': backup_file}, status=status.HTTP_200_OK)
       351         except RuntimeError as e:
       352             return Response({'message': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
     
     
     A.5 Код файлу database_backup.py
     
     
       1 import os
       2 import subprocess
       3 from datetime import datetime
       4 
       5 def get_backup_directory():
       6     # Determine the directory for the backup files
       7     script_directory = os.path.dirname(os.path.abspath(__file__))
       8     app_directory = os.path.dirname(script_directory)
       9     backup_directory = os.path.join(app_directory, 'backups')
       10 
       11     # Create the backup directory if it doesn't exist
       12     os.makedirs(backup_directory, exist_ok=True)
       13     return backup_directory
       14 
       15 def backup_database(host, port, database, user, password):
       16     # Generate a timestamp for the backup file
       17     timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
       18     
       19     # Determine the directory and file path for the backup
       20     backup_directory = get_backup_directory()
       21     backup_file = os.path.join(backup_directory, f'backup_{timestamp}.sql')
       22 
       23     # Path to the pg_dump executable
       24     pg_dump_path = 'C:\\Program Files\\PostgreSQL\\16\\bin\\pg_dump.exe'  # Update this path as necessary
       25 
       26     # Construct the pg_dump command
       27     pg_dump_command = [
       28         pg_dump_path,
       29         '-h', host,
       30         '-p', port,
       31         '-U', user,
       32         '-d', database,
       33         '-Fc',  # Custom format to include data
       34         '-f', backup_file
       35     ]
       36 
       37     # Environment variable for the password
       38     env = os.environ.copy()
       39     env['PGPASSWORD'] = password
       40 
       41     try:
       42         # Execute the pg_dump command
       43         subprocess.run(pg_dump_command, check=True, env=env)
       44         return backup_file
       45 
       46     except subprocess.CalledProcessError as error:
       47         # Raise an error if the backup fails
       48         raise RuntimeError(f"Error while backing up PostgreSQL database: {error}")
       
       
     А.6 Код файлу settings.py
     
1 import os
2 from pathlib import Path
3 
4 # Build paths inside the project like this: BASE_DIR / 'subdir'
5 BASE_DIR = Path(__file__).resolve().parent.parent
6 
7 # Quick-start development settings - unsuitable for production
8 # See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/
9 
10 # SECURITY WARNING: keep the secret key used in production secret!
11 SECRET_KEY = 'afba890d-eb8c-47a7-99e9-e874992b1ae0'
12 
13 # SECURITY WARNING: don't run with debug turned on in production!
14 DEBUG = True
15 
16 ALLOWED_HOSTS = []
17 
18 CORS_ALLOWED_ORIGINS = [
19     'http://localhost:3000',  # React development server
20 ]
21 
22 CSRF_TRUSTED_ORIGINS = [
23     "http://localhost:3000",
24 ]
25 
26 CORS_ALLOW_CREDENTIALS = True
27 
28 # Application references
29 # https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-INSTALLED_APPS
30 INSTALLED_APPS = [
31     'app',
32     # Add your apps here to enable them
33     'django.contrib.admin',
34     'django.contrib.auth',
35     'django.contrib.contenttypes',
36     'django.contrib.sessions',
37     'django.contrib.messages',
38     'django.contrib.staticfiles',
39     'rest_framework',
40     'corsheaders',
41 ]
42 
43 # Middleware framework
44 # https://docs.djangoproject.com/en/2.1/topics/http/middleware/
45 MIDDLEWARE = [
46     'corsheaders.middleware.CorsMiddleware',
47     'django.middleware.security.SecurityMiddleware',
48     'django.contrib.sessions.middleware.SessionMiddleware',
49     'django.middleware.common.CommonMiddleware',
50     'django.middleware.csrf.CsrfViewMiddleware',
51     'django.contrib.auth.middleware.AuthenticationMiddleware',
52     'django.contrib.messages.middleware.MessageMiddleware',
53     'django.middleware.clickjacking.XFrameOptionsMiddleware',
54 ]
55 
56 ROOT_URLCONF = 'LeashBuddy.urls'
57 
58 # Template configuration
59 # https://docs.djangoproject.com/en/2.1/topics/templates/
60 TEMPLATES = [
61     {
62         'BACKEND': 'django.template.backends.django.DjangoTemplates',
63         'DIRS': [],
64         'APP_DIRS': True,
65         'OPTIONS': {
66             'context_processors': [
67                 'django.template.context_processors.debug',
68                 'django.template.context_processors.request',
69                 'django.contrib.auth.context_processors.auth',
70                 'django.contrib.messages.context_processors.messages',
71             ],
72         },
73     },
74 ]
75 
76 WSGI_APPLICATION = 'LeashBuddy.wsgi.application'
77 
78 # Database
79 # https://docs.djangoproject.com/en/2.1/ref/settings/#databases
80 DATABASES = {
81     'default': {
82         'ENGINE': 'django.db.backends.postgresql',
83         'NAME': 'LeashBuddy',          
84         'USER': 'postgres',     
85         'PASSWORD': 'QAZPLM', 
86         'HOST': 'localhost',         
87         'PORT': '5432',              
88     }
89 }
90 
91 '''
92 # Password validation
93 # https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators
94 AUTH_PASSWORD_VALIDATORS = [
95     {
96         'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
97     },
98     {
99         'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
100     },
101     {
102         'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
103     },
104     {
105         'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
106     },
107 ]
108 '''
109 
110 
111 # Internationalization
112 # https://docs.djangoproject.com/en/2.1/topics/i18n/
113 LANGUAGE_CODE = 'en-us'
114 TIME_ZONE = 'UTC'
115 USE_I18N = True
116 USE_L10N = True
117 USE_TZ = True
118 
119 # Static files (CSS, JavaScript, Images)
120 # https://docs.djangoproject.com/en/2.1/howto/static-files/
121 STATIC_URL = '/static/'
122 STATIC_ROOT = BASE_DIR / 'static'  # Use pathlib to set the STATIC_ROOT path
123 
124 STATICFILES_DIRS = [
125     BASE_DIR / 'frontend/build/static',
126 ]
127 
128 DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
129 
130 AUTH_USER_MODEL = 'app.User' 

ДОДАТОК Б
     Програмний код IoT-пристрою
     Б.1 Код файлу esp32-dht22.ino:
     

1 /**
2    ESP32 + DHT22 Example for Wokwi
3    
4    https://wokwi.com/arduino/projects/322410731508073042
5 */
6 
7 #include <WiFi.h>
8 #include <HTTPClient.h>
9 #include "DHTesp.h"
10 
11 const int DHT_PIN = 15;
12 DHTesp dhtSensor;
13 
14 // Replace with your network credentials
15 const char* ssid = "Wokwi-GUEST";
16 const char* password = "";
17 
18 // Replace with your server endpoint
19 const char* server = "http://localhost:8000/update_temperature_data";
20 
21 unsigned long lastSendTime = 0;
22 const unsigned long sendInterval = 10000; // 10 seconds
23 
24 void setup() {
25   Serial.begin(115200);
26   
27   // Setup DHT22 sensor
28   dhtSensor.setup(DHT_PIN, DHTesp::DHT22);
29 
30   // Connect to Wi-Fi
31   WiFi.begin(ssid, password);
32   Serial.print("Connecting to Wi-Fi");
33   while (WiFi.status() != WL_CONNECTED) {
34     delay(500);
35     Serial.print(".");
36   }
37   Serial.println(" Connected to Wi-Fi");
38 }
39 
40 void loop() {
41   TempAndHumidity data = dhtSensor.getTempAndHumidity();
42   
43   // Check if the sensor is providing valid data
44   if (isnan(data.temperature) || isnan(data.humidity)) {
45     Serial.println("Failed to read from DHT sensor!");
46     return;
47   }
48   
49   Serial.println("Temp: " + String(data.temperature, 2) + "В°C");
50   
51   Serial.println("---");
52 
53   unsigned long currentTime = millis();
54 
55   // Only send data every `sendInterval`
56   if (currentTime - lastSendTime >= sendInterval) {
57     lastSendTime = currentTime;
58 
59     // Send the data to the server
60     if (WiFi.status() == WL_CONNECTED) {
61       HTTPClient http;
62       http.setTimeout(5000); 
63       http.begin(server);
64       http.addHeader("Content-Type", "application/x-www-form-urlencoded");
65 
66       String postData = "temperature=" + String(data.temperature, 2) + "&humidity=" + String(data.humidity, 1);
67       int httpResponseCode = http.POST(postData);
68 
69       if (httpResponseCode > 0) {
70         String response = http.getString();
71         Serial.println(httpResponseCode);
72         Serial.println(response);
73       } else {
74         Serial.print("Error on sending POST: ");
75         Serial.println(httpResponseCode);
76       }
77 
78       http.end();
79     }
80   }
81 
82   delay(2000); // Wait for a new reading from the sensor (DHT22 has ~0.5Hz sample rate)
83 } 

ДОДАТОК В
     Програмний код клієнтської частини
     В.1 Код файлу Register.js
     
     
       1 import React, { useState, useEffect } from 'react';
       2 import { useNavigate, Link } from 'react-router-dom';
       3 import axiosInstance from '../../api/axiosInstance';
       4 import { fetchCsrfToken } from '../../api/csrf';
       5 import { useUser } from '../Shared/UserContext';
       6 import styles from './auth.module.css';
       7 
       8 const Register = () => {
       9   const [email, setEmail] = useState('');
       10   const [password, setPassword] = useState('');
       11   const [confirmPassword, setConfirmPassword] = useState('');
       12   const [firstName, setFirstName] = useState('');
       13   const [secondName, setSecondName] = useState('');  
       14   const [phone, setPhone] = useState('');
       15   const [address, setAddress] = useState('');
       16   const [error, setError] = useState('');
       17   const navigate = useNavigate();
       18   const { login } = useUser();
       19 
       20   useEffect(() => {
       21     const setCsrfToken = async () => {
       22       await fetchCsrfToken();
       23     };
       24     setCsrfToken();
       25   }, []);
       26 
       27   const handleSubmit = async (e) => {
       28     e.preventDefault();
       29     if (password !== confirmPassword) {
       30       setError("Passwords do not match");
       31       return;
       32     }
       33     try {
       34       const response = await axiosInstance.post('/api/register/', {
       35         email,
       36         password,
       37         first_name: firstName,
       38         second_name: secondName,
       39         phone,
       40         address
       41       });
       42       if (response.status === 201 && response.data) {
       43         login({ email: response.data.email, role: response.data.role });
       44         navigate('/');
       45       } else {
       46         setError('Registration failed');
       47       }
       48     } catch (err) {
       49       setError('Registration failed');
       50     }
       51   };
       52 
       53   return (
       54     <form onSubmit={handleSubmit} className={styles.authForm}>
       55       <h1 className={styles.title}>LeashBuddy</h1>
       56       <label>
       57         First Name:
       58         <input type="text" value={firstName} onChange={(e) => setFirstName(e.target.value)} />
       59       </label>
       60       <label>
       61         Second Name:
       62         <input type="text" value={secondName} onChange={(e) => setSecondName(e.target.value)} />
       63       </label>
       64       <label>
       65         Phone:
       66         <input type="text" value={phone} onChange={(e) => setPhone(e.target.value)} />
       67       </label>
       68       <label>
       69         Address:
       70         <input type="text" value={address} onChange={(e) => setAddress(e.target.value)} />
       71       </label>
       72       <label>
       73         Email:
       74         <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} />
       75       </label>
       76       <label>
       77         Password:
       78         <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
       79       </label>
       80       <label>
       81         Confirm Password:
       82         <input type="password" value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} />
       83       </label>
       84       {error && <p className={styles.error}>{error}</p>}
       85       <button type="submit">Register</button>
       86       <div className={styles.linkContainer}>
       87         <p>Already have an account? <Link to="/login">Login here</Link></p>
       88       </div>
       89     </form>
       90   );
       91 };
       92 
       93 export default Register;
       

     В.2 Код файлу PetDetail.js
     
     
1 import React, { useEffect, useState } from 'react';
2 import { useParams, useNavigate } from 'react-router-dom';
3 import axiosInstance from '../../api/axiosInstance';
4 import { Line } from 'react-chartjs-2';
5 import {
6   Chart as ChartJS,
7   CategoryScale,
8   LinearScale,
9   PointElement,
10   LineElement,
11   Title,
12   Tooltip,
13   Legend,
14 } from 'chart.js';
15 import ReminderNotification from './ReminderNotification';
16 import PetDietManagement from './PetDietManagement';
17 import PetExerciseManagement from './PetExerciseManagement';
18 import styles from './PetDetail.module.css';
19 
20 // Register Chart.js components
21 ChartJS.register(
22   CategoryScale,
23   LinearScale,
24   PointElement,
25   LineElement,
26   Title,
27   Tooltip,
28   Legend
29 );
30 
31 function PetDetail() {
32   const { id } = useParams();
33   const [pet, setPet] = useState(null);
34   const [dietData, setDietData] = useState([]);
35   const [exerciseData, setExerciseData] = useState([]);
36   const [loading, setLoading] = useState(true);
37   const [nextDiet, setNextDiet] = useState(null);
38   const [nextExercise, setNextExercise] = useState(null);
39   const [diets, setDiets] = useState([]);
40   const [exercises, setExercises] = useState([]);
41   const [petDiets, setPetDiets] = useState([]);
42   const [petExercises, setPetExercises] = useState([]);
43   const [currentTemperature, setCurrentTemperature] = useState(null);
44   const [showDietGraph, setShowDietGraph] = useState(true);
45   const [showExerciseGraph, setShowExerciseGraph] = useState(true);
46   const navigate = useNavigate();
47 
48   useEffect(() => {
49     axiosInstance.get(`/api/pets/${id}/`)
50       .then(response => {
51         setPet(response.data);
52         setLoading(false);
53       })
54       .catch(error => {
55         console.error('Fetch error:', error);
56         setLoading(false);
57       });
58 
59     axiosInstance.get(`/api/pets/${id}/diets/`)
60       .then(response => {
61         const diets = response.data;
62         setDietData(diets);
63 
64         const upcomingDiets = diets.filter(diet => new Date(diet.date) > new Date());
65         if (upcomingDiets.length > 0) {
66           const nextDiet = upcomingDiets.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date;
67           setNextDiet(nextDiet);
68         } else {
69           setNextDiet(null);
70         }
71       })
72       .catch(error => {
73         console.error('Fetch diet data error:', error);
74       });
75 
76     axiosInstance.get(`/api/pets/${id}/exercises/`)
77       .then(response => {
78         const exercises = response.data;
79         const processedExerciseData = exercises.map(item => ({
80           ...item,
81           duration: parseInt(item.duration.split(':')[0], 10) * 60 + parseInt(item.duration.split(':')[1], 10)
82         }));
83         setExerciseData(processedExerciseData);
84 
85         const upcomingExercises = exercises.filter(exercise => new Date(exercise.date) > new Date());
86         if (upcomingExercises.length > 0) {
87           const nextExercise = upcomingExercises.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date;
88           setNextExercise(nextExercise);
89         } else {
90           setNextExercise(null);
91         }
92       })
93       .catch(error => {
94         console.error('Fetch exercise data error:', error);
95       });
96 
97     axiosInstance.get('/api/diets/')
98       .then(response => {
99         setDiets(response.data);
100       })
101       .catch(error => {
102         console.error('Fetch diets error:', error);
103       });
104 
105     axiosInstance.get('/api/exercises/')
106       .then(response => {
107         setExercises(response.data);
108       })
109       .catch(error => {
110         console.error('Fetch exercises error:', error);
111       });
112 
113     axiosInstance.get(`/api/sensors/?pet=${id}&ordering=-timestamp&limit=1`)
114       .then(response => {
115         if (response.data.length > 0) {
116           setCurrentTemperature(response.data[0]);
117         }
118       })
119       .catch(error => {
120         console.error('Fetch sensor data error:', error);
121       });
122 
123   }, [id]);
124 
125   if (loading) {
126     return <div>Loading...</div>;
127   }
128 
129   if (!pet) {
130     return <div>Pet not found</div>;
131   }
132 
133   const handleEdit = () => {
134     navigate(`/pets/edit/${id}`);
135   };
136 
137   const dietChartData = {
138     labels: dietData.map(item => item.date),
139     datasets: [
140       {
141         label: 'Feeding Quantity',
142         data: dietData.map(item => item.quantity),
143         borderColor: 'rgba(75,192,192,1)',
144         borderWidth: 2,
145         fill: false,
146       },
147     ],
148   };
149 
150   const exerciseChartData = {
151     labels: exerciseData.map(item => item.date),
152     datasets: [
153       {
154         label: 'Exercise Duration (minutes)',
155         data: exerciseData.map(item => item.duration),
156         borderColor: 'rgba(153,102,255,1)',
157         borderWidth: 2,
158         fill: false,
159       },
160     ],
161   };
162 
163   return (
164     <div className={styles.petDetailContainer}>
165       <ReminderNotification nextDiet={nextDiet} nextExercise={nextExercise} />
166       <h1>{pet.name}</h1>
167       <p>Breed: {pet.breed}</p>
168       <p>Age: {pet.age}</p>
169       <p>Gender: {pet.gender}</p>
170       <p>Weight: {pet.weight} kg</p>
171       <h2>Current Temperature</h2>
172       {currentTemperature ? (
173         <p>Latest recorded temperature: {currentTemperature.temperature}В°C at {new Date(currentTemperature.timestamp).toLocaleString()}</p>
174       ) : (
175         <p>No temperature data available for this pet.</p>
176       )}
177       <h2>Owner Details</h2>
178       {pet.user ? (
179         <>
180           <p>Full Name: {pet.user.first_name} {pet.user.second_name}</p>
181           <p>Phone: {pet.user.phone}</p>
182         </>
183       ) : (
184         <p>Owner information not available</p>
185       )}
186       <button className={styles.actionButton} onClick={handleEdit}>Edit</button>
187 
188       <h2>Feeding Graph</h2>
189       <button className={styles.actionButton} onClick={() => setShowDietGraph(!showDietGraph)}>
190         {showDietGraph ? 'Hide Feeding Graph' : 'Show Feeding Graph'}
191       </button>
192       {showDietGraph && (
193         <div className={styles.chartContainer}>
194           <Line data={dietChartData} />
195         </div>
196       )}
197       <PetDietManagement petId={id} diets={diets} petDiets={petDiets} setPetDiets={setPetDiets} />
198 
199       <h2>Exercise Graph</h2>
200       <button className={styles.actionButton} onClick={() => setShowExerciseGraph(!showExerciseGraph)}>
201         {showExerciseGraph ? 'Hide Exercise Graph' : 'Show Exercise Graph'}
202       </button>
203       {showExerciseGraph && (
204         <div className={styles.chartContainer}>
205           <Line data={exerciseChartData} />
206         </div>
207       )}
208       <PetExerciseManagement petId={id} exercises={exercises} petExercises={petExercises} setPetExercises={setPetExercises} />
209     </div>
210   );
211 }
212 
213 export default PetDetail;



